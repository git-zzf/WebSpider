[TOC]



# 第三周内容导学

讲解正则表达式库，它能在页面中提取关键信息。

结合两个实例讲解Requests库，BeautifulSoup库和正则表达式库联合进行网络爬虫跟信息提取的方法。

实例1：淘宝商品比价定向爬虫

实例2：股票数据定向爬虫



****

# 正则表达式的概念

## 正则表达式

regular expression，也叫regex，RE

正则表达式是用来简洁表达一组字符串的表达式

设想我们有一组字符串：

```
'PN'
'PYN'
'PYTN'
'PYTHN'
'PYTHON'
```

表达一组字符串的方式就是将他们一一列举出来，不过这种方式既繁琐，又占用空间。

正则表达式就是一种更简洁的表示方法。

对应上面的字符串，它的正则表达式只有一行：

```
P(Y|YT|YTH|YTHO)?N
```

****



## 为什么需要使用正则表达式？

因为简洁，正则表达式可以非常简洁地表达很大一组字符串的特征，所以正则表达式是“一行胜千言”，正则表达式表示了一组字符串的特征或模式

### 例子1，无穷字符串组：

```
'PY'
'PYY'
'PYYY'
'PYYYY'
....
'PYYYY....'
```

正则表达式可以表示为：

```
PY+
```

表示无穷多个以P开头但是后面只有一个或无穷多个Y这样的字符串组



### 例子2，有穷个具有共同特点的字符串，枚举很繁琐：

```
'PY'开头
后续存在不多于10个字符
后续字符不能是'P'或'Y'
正确：'PYABC'
错误：'PYKXYZ'
```

正则表达式：

```
PY[^PY]{0,10}
```

****



## 总结

正则表达式

+ 通用的字符串表达框架
+ 简洁表达一组字符串的表达式，与一组字符串是等价的
+ 针对字符串表达“简洁”和“特征”思想的工具，即用很简单的方法表达更多的字符串，或在字符串中凝练更多的特征，可以用正则表达式
+ 用来判断字符串是否属于某个特征



正则表达式在文本处理中的作用：

+ 表达文本类型的特征（病毒、入侵等）
+ 同时查找或替换一组字符串
+ 匹配字符串的全部或部分
+ 主要应用在字符串匹配中



正则表达式的使用：

编译：将符合正则表达式语法的字符串转换成正则表达式特征：

```
'PN'
'PYN'
'PYTN'
'PYTHN'
'PYTHON'

正则表达式：
P(Y|YT|YTH|YTHO)?N
regex = 'P(Y|YT|YTH|YTHO)?N'

编译：
p = re.compile(regex)
```

通过编译将字符串变成一个特征，这个特征可以表达一组字符串。

编译之后的特征与一组字符串是对应的，而编译前的正则表达式只是一个符合正则表达式语法的一个单一的字符串，但他并不是真正意义上的正则表达式



****

# 正则表达式的语法

正则表达式由字符和操作符构成

## 正则表达式常用操作符：

| 操作符 | 说明                             | 实例                                    |
| ------ | -------------------------------- | --------------------------------------- |
| .      | 表示任何单个字符                 |                                         |
| []     | 字符集，对单个字符给出取值范围   | [abc]表示a、b、c、[a-z]表示a到z单个字符 |
| [^ ]   | 非字符集，对单个字符给出排除范围 | [^abc]表示非a或b或c的单个字符           |
| *      | 前一个字符0次或无限次扩展        | abc*表示ab、abc、abcc、abccc等          |
| +      | 前一个字符1次或无限次扩展        | abc+表示abc、abcc、abccc等              |
| ?      | 前一个字符0次或1次扩展           | abc？表示ab、abc                        |
| \|     | 左右表达式任意一个               | abc\|def表示abc、def                    |
| {m}    | 扩展前一个字符m次                | ab{2}c表示abbc                          |
| {m,n}  | 扩展前一个字符m至n次（含n）      | ab{1,2}c表示abc、abbc                   |
| ^      | 匹配字符串开头                   | ^abc表示abc，而且abc在一个字符串的开头  |
| $      | 匹配字符串结尾                   | abc$表示abc且在一个字符串的结尾         |
| ( )    | 分组标记，内部只能使用\|操作符   | (abc)表示abc，(abc\|def)表示abc、def    |
| \d     | 数字，等价于[0-9]                |                                         |
| \w     | 单词字符，等价于[A-Za-z0-9_]     |                                         |



## 正则表达式实例：

```
正则表达式
P(Y|YT|YTH|YTHO)?N
对应字符串
'PN'、'PYN'、'PYTN'、'PYTHN'、'PYTHON'
```

?号表示之前的部分的0次或1次扩展，()加|表示选择其中的一个元素



```
正则表达式
PYTHON+
对应字符串
'PYTHON'、'PYTHONN'、'PYTHONNN'...
```

+号表示+号之前的元素1次或无限次扩展



```
正则表达式
PY[TH]ON
对应字符串
'PYTON'、'PYHON'
```

表示PY和ON之间的字母是从TH中选择一个字符



```
正则表达式
PY[^TH]?ON
对应字符串
'PYON'、'PYaON'、'PYbON'、'PYcON'...
```

表示从只要不是大写T或者H的字符中，选择0个或1个放到PY和ON之间



```
正则表达式
PY{:3}N
对应字符串
'PN'、'PYN'、'PYYN'、'PYYYN'
```

在PY和N之间拓展Y三次，{m}表示拓展大括号之前的字符m次



## 经典正则表达式实例：

```
^[A-Za-z]+$				由26个字母组成的字符串
^[A-Za-z0-9]+$			由26个字母和数字组成的字符串
^-?\d+$					整数形式的字符串
^[0-9]*[1-9][0-9]*$		正整数形式的字符串
[1-9]\d{5}				中国境内邮政编码，6位
[\u4e00-\u9fa5]			匹配中文字符，utf-8
\d{3}-\d{8}|d{4}-\d{7}	国内电话号码，如010-6813536
```



## 根据字符串构造正则表达式

IP地址字符串形式的正则表达式（IP地址分4段，每段0-255）

```
\d+.\d+.|d+.\d+						不考虑每一段的取值范围和空间，只考虑.的分隔
\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}.	可以重复1到3个数字
```

但是这两种方法都不精确，比如300.300.300.300这个地址无法用第二种表示

需要分段表示：

```
精确写法：
0-99:			[1-9]?\d
100-199:		1\d{2}
200-249:		2[0-4]\d
250-255:		25[0-5]
```

结合起来，用|连接

```
(([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5])
```



****

# Re库的基本使用

Re库是Python的标准库，无需额外安装，主要用于字符串匹配，调用方法：`improt re`

## 正则表达式的表示类型

+ raw string类型（原生字符串类型）：`r'text'`

例如：

```
r'[1-9]\d{5}'
r'\d{3}-\d{8}|\d{4}-\d{7}'
```

原生字符串的意思是不包含转义符的字符串



+ 正则表达式也可以使用string类型，不过更繁琐

同样的例子：

```
'[1-9]\\d{5}'
'\\d{3}-\\d{8}|\\d{4}-\\d{7}'
```

因此当正则表达式中出现转义符的时候，建议使用raw string类型来表示

****

## Re库主要功能函数

| 函数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| re.search()   | 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象  |
| re.match()    | 从一个字符串的开始位置起匹配正则表达式，返回match对象        |
| re.findall()  | 搜索字符串，以列表类型返回全部能匹配的子串                   |
| re.split()    | 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型     |
| re.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 |
| re.sub()      | 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 |



### re.search(pattern, string, flags=0)

 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象

+ pattern：正则表达式的字符串或原生字符串表示
+ string：待匹配的字符串
+ flags：正则表达式使用时的控制标记

通过正则表达式匹配一个string同时用一些标记来控制查找。

| 常用标记            | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| re.I, re.IGNORECASE | 忽略正则表达式的大小写，[A-Z]能够匹配小写字符                |
| re.M, re.MULTILINE  | 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始      |
| re.S, re.DOTALL     | 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符 |

例子：

```python
>>> import re
>>> match = re.search(r'[1-9]\d{5}', 'BIT 100081')
>>> if match:
    print(match.group(0))

100081
```



### re.match(pattern, string, flags=0)

从一个字符串的开始位置起匹配正则表达式，返回match对象

+ pattern：正则表达式的字符串或原生字符串表示
+ string：待匹配的字符串
+ flags：正则表达式使用时的控制标记

例子：

```python
>>> import re
>>> match = re.match(r'[1-9]\d{5}', 'BIT 100081')
>>> if match:
    print(match.group(0))
    
    
```

没有结果，直接看match

```python
>>> match.group(0)
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    match.group(0)
AttributeError: 'NoneType' object has no attribute 'group'
```

发现报错，NoneType，意思是返回的match并没有group(0)这个属性，也就是说这个match是空的。这是因为，match函数是从起始位置匹配，而'BIT 100081'并不是以邮政编码开头的，所以返回的是空。

因此，当我们想要使用match变量的时候，需要用if进行判断，不然系统可能会报错

调整输入参数：

```python
>>> match = re.match(r'[1-9]\d{5}', '100081 BIT')
>>> if match:
    print(match.group(0))
    
100081
```



### re.findall(pattern, string, flags=0)

搜索字符串，以列表类型返回全部能匹配的子串

+ pattern：正则表达式的字符串或原生字符串表示
+ string：待匹配的字符串
+ flags：正则表达式使用时的控制标记

``` python
>>> import re
>>> ls = re.findall(r'[1-9]\d{5}', 'BIT100081 TSU100084')
>>> ls
['100081','100084']
```

re.findall()可以把所有匹配正则表达式的字符串都打印出来



### re.split(pattern, string, maxsplit=0, flags=0)

将一个字符串按照正则表达式匹配结果进行分割，返回列表类型

+ pattern：正则表达式的字符串或原生字符串表示
+ string：待匹配的字符串
+ maxsplit：最大分割数，剩余部分作为最后一个元素输出（希望这个字符串分成多少部分）
+ flags：正则表达式使用时的控制标记

例子：

```python
>>> import re
>>> re.split(r'[1-9]\d{5}', 'BIT100081 TSU100084')
['BIT', ' TSU', '']
```

re.split()函数作用是匹配字符串，把匹配的部分去掉，去掉之后的部分分别作为分割的字符串元素放到一个列表里

增加maxsplit参数：

```python
>>> re.split(r'[1-9]\d{5}', 'BIT100081 TSU100084', maxsplit = 1)
['BIT', ' TSU100084']
```

由于maxsplit = 1，所以只匹配第一个位置，匹配之后，将BIT分割出来，剩下的所有部分作为一个完整的字符串放在列表结尾输出



### re.finditer(pattern, string, flags=0)

搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象

+ pattern：正则表达式的字符串或原生字符串表示
+ string：待匹配的字符串
+ flags：正则表达式使用时的控制标记

例子：

```python
>>> import re
>>> for m in re.finditer(r'[1-9]\d{5}', 'BIT100081 TSU100084'):
    if m:
        print(m.group(0))
        
100081
100084
```

通过re.finditer()函数可以迭代地获得每一次正则表达式匹配的结果，并对这个结果单独进行处理

```python
>>> re.finditer(r'[1-9]\d{5}', 'BIT100081 TSU100084')
<callable_iterator object at 0x03945F70>
```

re.finditer()函数的结果是迭代类型



### re.sub(pattern, repl, string, count=0, flags=0)

在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串，简单来说，就是用一个新的字符串替换正则表达式匹配上的那些字符串，并与原来的字符串进行组合，返回一个新的字符串

+ pattern：正则表达式的字符串或原生字符串表示
+ repl：替换匹配字符串的字符串
+ string：待匹配的字符串
+ count：匹配的最大替换次数
+ flags：正则表达式使用时的控制标记

例子：

```python
>>> import re
>>> re.sub(r'[1-9]\d{5}',':zipcode' , 'BIT100081 TSU100084')
'BIT:zipcode TSU:zipcode'
```

输出的字符串中的邮政编码部分被':zipcode'代替了。



****

## RE库的另一种等价用法

### 函数式用法

```python
>>> rst = re.search(r'[1-9]\d{5}', 'BIT 100081')
```

对于一次性操作可以用



### 面向对象用法

```python
>>> pat = re.compile(r'[1-9]\d{5}')
>>> rst = pat.search('BIT 100081')
```

编译后的多次操作，包含两个部分

1. 首先使用`re.compile()`将一个正则表达式的字符串编译成为一个正则表达式类型，pattern类型
2. 然后我们用这个pattern对象，直接调用`.search()`、`.match()`等6个方法来获得相关结果

这种方法的好处是，经过一次编译，当我们需要多次对正则表达式进行使用和匹配时，就可以使用这种方式来加快整个程序的运行。



### regex = re.compile(pattern, flags=0)

将正则表达式的字符串形式编译成正则表达式对象

+ pattern：正则表达式的字符串或原生字符串表示
+ flags：正则表达式使用时的控制标记

要注意：正则表达式的字符串或原生字符串表示并不是正则表达式，只是一种表示。

如果通过`regex = re.compile()`生成了一个对象`regex`，这个`regex`才是正则表达式。他代表了一组字符串。

`regex`对象的6种方法，类似re的方法：

| 函数             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| regex.search()   | 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象  |
| regex.match()    | 从一个字符串的开始位置起匹配正则表达式，返回match对象        |
| regex.findall()  | 搜索字符串，以列表类型返回全部能匹配的子串                   |
| regex.split()    | 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型     |
| regex.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 |
| regex.sub()      | 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 |

注意：在使用对象的方法的时候，由于已经编译过变成正则表达式了，就不需要在方法里写正则表达式的参数了，如`r'[1-9]\d{5}'`，只需要给出需要匹配的字符串就可以了。



****

# Re库的Match对象

Match对象是`re.search()`，`re.match()`方法返回的结果，也就是一次匹配的结果，包含了匹配的相关信息

例子：

```python
>>> import re
>>> match = re.search(r'[1-9]\d{5}', 'BIT 100081')
>>> if match:
    print(match.group(0))

100081
>>> type(match)
<class 're.Match'>
```

****

## Match对象的属性：

| 属性    | 说明                                  |
| ------- | ------------------------------------- |
| .string | 待匹配的文本                          |
| .re     | 匹配时使用的pattern对象（正则表达式） |
| .pos    | 正则表达式搜索文本的开始位置          |
| .endpos | 正则表达式搜索文本的结束位置          |

## Match对象的方法：

| 方法      | 说明                             |
| --------- | -------------------------------- |
| .group(0) | 获得匹配后的字符串               |
| .start()  | 匹配字符串在原始字符串的开始位置 |
| .end()    | 匹配字符串在原始字符串的结束位置 |
| .span()   | 返回(.start(), .end())           |

****

实例：

```python
>>> import re
>>> m = re.search(r'[1-9]\d{5}', 'BIT100081 TSU100084')
>>> m.string
'BIT100081 TSU100084'
```

`m.string`输出的就是用户输入的待匹配的字符串

```python
>>> m.re
re.compile('[1-9]\\d{5}')
```

`m.re`输出的是，匹配使用的正则表达式，这个正则表达式是带着`re.compile()`函数标识的，也就说明在程序内部认为，只有在编译后的正则表达式才是一个正则表达式，没有编译过的正则表达式仅仅是正则表达式的一种表示。

```python
>>> m.pos
0
>>> m.endpos
19
```

可以看到`re.search()`函数是对字符串从最开始的0位置到最后一个19位置进行搜索的。

```python
>>> m.group(0)
'100081'
```

匹配结果，存在`m.group(0)`内容中，要注意的是，match对象只包含第一次匹配的结果。在这里进行了两次匹配，一次匹配100081，一次匹配100084。match对象返回的是第一次匹配的结果。如果想到得到每一次返回的match对象，需要使用re.finditer()这个函数来实现。

```python
>>> m.start()
3
>>> m.end(9)
9
>>> m.span()
(3, 9)
```

匹配的起始位置，终结位置以及这两个位置的二元关系。



****

# Re库的贪婪匹配和最小匹配

实例：

```python
>>> match = re.search(r'PY.*N', 'PYANBNCNDN')
>>> match.group(0)
```

正则表达式的意思是：以PY开头以N结尾，中间可以有若干字符串

待匹配的字符串是：`PYANBNCNDN`

我们可以看到，这样的一个正则表达式可以在给定的字符串中存在多项匹配，对于这个例子，有4项匹配，每种匹配长短也不同。

如何判断返回的结果？

Re库默认采用<font color = red>贪婪匹配</font>，即输出匹配最长的子串，并返回这个子串

所以如果我们不加任何标识，只使用`re.search()`函数，我们将返回：

```python
'PYANBNCNDN'
```

如果我们想要最小匹配，就需要将原先的正则表达式扩展一下：

```python
>>> match = re.search(r'PY.*?N', 'PYANBNCNDN')
>>> match.group(0)
'PYAN'
```

加上一个问号就可以匹配最小的字符串（问号代表前一个字符的0次或1次扩展）



## 最小匹配操作符：

| 操作符  |                 说明                  |
| :-----: | :-----------------------------------: |
|   *?    |  前一个字符0次或无限次扩展，最小匹配  |
|   +?    |  前一个字符1次或无限次扩展，最小匹配  |
|   ??    |  前一个字符串0次或1次扩展，最小匹配   |
| {m, n}? | 扩展前一个字符m至n次（含n），最小匹配 |



当我们看到有操作符可以匹配不同长度的时候，都可以在后面加上一个问号，表示最小匹配



****

# 单元小结

## Re库（正则表达式）入门：

正则表达式是用来简洁表达一组字符串的表达式

```python
r'\d{3}-\d{8}|d{4}-\d{7}'
```

正则表达式可以非常简洁地表达很大一组字符串的特征



## Re库（正则表达式）的6个函数

函数式用法：

| 函数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| re.search()   | 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象  |
| re.match()    | 从一个字符串的开始位置起匹配正则表达式，返回match对象        |
| re.findall()  | 搜索字符串，以列表类型返回全部能匹配的子串                   |
| re.split()    | 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型     |
| re.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 |
| re.sub()      | 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 |

面向对象用法：

1. 先通过`regex = re.compile()`构建一个对象
2. 使用对象的6个方法

| 函数             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| regex.search()   | 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象  |
| regex.match()    | 从一个字符串的开始位置起匹配正则表达式，返回match对象        |
| regex.findall()  | 搜索字符串，以列表类型返回全部能匹配的子串                   |
| regex.split()    | 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型     |
| regex.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 |
| regex.sub()      | 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 |



正则表达式很好地支撑了文本匹配，文本替换的工作，很常用