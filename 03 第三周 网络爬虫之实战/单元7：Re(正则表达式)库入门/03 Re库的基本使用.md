# Re库的基本使用

Re库是Python的标准库，无需额外安装，主要用于字符串匹配，调用方法：`improt re`

## 正则表达式的表示类型

+ raw string类型（原生字符串类型）：`r'text'`

例如：

```
r'[1-9]\d{5}'
r'\d{3}-\d{8}|\d{4}-\d{7}'
```

原生字符串的意思是不包含转义符的字符串



+ 正则表达式也可以使用string类型，不过更繁琐

同样的例子：

```
'[1-9]\\d{5}'
'\\d{3}-\\d{8}|\\d{4}-\\d{7}'
```

因此当正则表达式中出现转义符的时候，建议使用raw string类型来表示

****

## Re库主要功能函数

| 函数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| re.search()   | 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象  |
| re.match()    | 从一个字符串的开始位置起匹配正则表达式，返回match对象        |
| re.findall()  | 搜索字符串，以列表类型返回全部能匹配的子串                   |
| re.split()    | 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型     |
| re.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 |
| re.sub()      | 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 |



### re.search(pattern, string, flags=0)

 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象

+ pattern：正则表达式的字符串或原生字符串表示
+ string：待匹配的字符串
+ flags：正则表达式使用时的控制标记

通过正则表达式匹配一个string同时用一些标记来控制查找。

| 常用标记            | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| re.I, re.IGNORECASE | 忽略正则表达式的大小写，[A-Z]能够匹配小写字符                |
| re.M, re.MULTILINE  | 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始      |
| re.S, re.DOTALL     | 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符 |

例子：

```python
>>> import re
>>> match = re.search(r'[1-9]\d{5}', 'BIT 100081')
>>> if match:
    print(match.group(0))

100081
```



### re.match(pattern, string, flags=0)

从一个字符串的开始位置起匹配正则表达式，返回match对象

+ pattern：正则表达式的字符串或原生字符串表示
+ string：待匹配的字符串
+ flags：正则表达式使用时的控制标记

例子：

```python
>>> import re
>>> match = re.match(r'[1-9]\d{5}', 'BIT 100081')
>>> if match:
    print(match.group(0))
    
    
```

没有结果，直接看match

```python
>>> match.group(0)
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    match.group(0)
AttributeError: 'NoneType' object has no attribute 'group'
```

发现报错，NoneType，意思是返回的match并没有group(0)这个属性，也就是说这个match是空的。这是因为，match函数是从起始位置匹配，而'BIT 100081'并不是以邮政编码开头的，所以返回的是空。

因此，当我们想要使用match变量的时候，需要用if进行判断，不然系统可能会报错

调整输入参数：

```python
>>> match = re.match(r'[1-9]\d{5}', '100081 BIT')
>>> if match:
    print(match.group(0))
    
100081
```



### re.findall(pattern, string, flags=0)

搜索字符串，以列表类型返回全部能匹配的子串

+ pattern：正则表达式的字符串或原生字符串表示
+ string：待匹配的字符串
+ flags：正则表达式使用时的控制标记

``` python
>>> import re
>>> ls = re.findall(r'[1-9]\d{5}', 'BIT100081 TSU100084')
>>> ls
['100081','100084']
```

re.findall()可以把所有匹配正则表达式的字符串都打印出来



### re.split(pattern, string, maxsplit=0, flags=0)

将一个字符串按照正则表达式匹配结果进行分割，返回列表类型

+ pattern：正则表达式的字符串或原生字符串表示
+ string：待匹配的字符串
+ maxsplit：最大分割数，剩余部分作为最后一个元素输出（希望这个字符串分成多少部分）
+ flags：正则表达式使用时的控制标记

例子：

```python
>>> import re
>>> re.split(r'[1-9]\d{5}', 'BIT100081 TSU100084')
['BIT', ' TSU', '']
```

re.split()函数作用是匹配字符串，把匹配的部分去掉，去掉之后的部分分别作为分割的字符串元素放到一个列表里

增加maxsplit参数：

```python
>>> re.split(r'[1-9]\d{5}', 'BIT100081 TSU100084', maxsplit = 1)
['BIT', ' TSU100084']
```

由于maxsplit = 1，所以只匹配第一个位置，匹配之后，将BIT分割出来，剩下的所有部分作为一个完整的字符串放在列表结尾输出



### re.finditer(pattern, string, flags=0)

搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象

+ pattern：正则表达式的字符串或原生字符串表示
+ string：待匹配的字符串
+ flags：正则表达式使用时的控制标记

例子：

```python
>>> import re
>>> for m in re.finditer(r'[1-9]\d{5}', 'BIT100081 TSU100084'):
    if m:
        print(m.group(0))
        
100081
100084
```

通过re.finditer()函数可以迭代地获得每一次正则表达式匹配的结果，并对这个结果单独进行处理

```python
>>> re.finditer(r'[1-9]\d{5}', 'BIT100081 TSU100084')
<callable_iterator object at 0x03945F70>
```

re.finditer()函数的结果是迭代类型



### re.sub(pattern, repl, string, count=0, flags=0)

在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串，简单来说，就是用一个新的字符串替换正则表达式匹配上的那些字符串，并与原来的字符串进行组合，返回一个新的字符串

+ pattern：正则表达式的字符串或原生字符串表示
+ repl：替换匹配字符串的字符串
+ string：待匹配的字符串
+ count：匹配的最大替换次数
+ flags：正则表达式使用时的控制标记

例子：

```python
>>> import re
>>> re.sub(r'[1-9]\d{5}',':zipcode' , 'BIT100081 TSU100084')
'BIT:zipcode TSU:zipcode'
```

输出的字符串中的邮政编码部分被':zipcode'代替了。



****

## RE库的另一种等价用法

### 函数式用法

```python
>>> rst = re.search(r'[1-9]\d{5}', 'BIT 100081')
```

对于一次性操作可以用



### 面向对象用法

```python
>>> pat = re.compile(r'[1-9]\d{5}')
>>> rst = pat.search('BIT 100081')
```

编译后的多次操作，包含两个部分

1. 首先使用`re.compile()`将一个正则表达式的字符串编译成为一个正则表达式类型，pattern类型
2. 然后我们用这个pattern对象，直接调用`.search()`、`.match()`等6个方法来获得相关结果

这种方法的好处是，经过一次编译，当我们需要多次对正则表达式进行使用和匹配时，就可以使用这种方式来加快整个程序的运行。



### regex = re.compile(pattern, flags=0)

将正则表达式的字符串形式编译成正则表达式对象

+ pattern：正则表达式的字符串或原生字符串表示
+ flags：正则表达式使用时的控制标记

要注意：正则表达式的字符串或原生字符串表示并不是正则表达式，只是一种表示。

如果通过`regex = re.compile()`生成了一个对象`regex`，这个`regex`才是正则表达式。他代表了一组字符串。

`regex`对象的6种方法，类似re的方法：

| 函数             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| regex.search()   | 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象  |
| regex.match()    | 从一个字符串的开始位置起匹配正则表达式，返回match对象        |
| regex.findall()  | 搜索字符串，以列表类型返回全部能匹配的子串                   |
| regex.split()    | 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型     |
| regex.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 |
| regex.sub()      | 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 |

注意：在使用对象的方法的时候，由于已经编译过变成正则表达式了，就不需要在方法里写正则表达式的参数了，如`r'[1-9]\d{5}'`，只需要给出需要匹配的字符串就可以了。